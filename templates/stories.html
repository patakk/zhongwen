<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Domine:wght@400..700&family=Noto+Serif+JP:wght@200..900&display=swap"
        rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@0,200..900;1,200..900&display=swap"
        rel="stylesheet">
    <link
        href="https://fonts.googleapis.com/css2?family=Nunito+Sans:ital,opsz,wght@0,6..12,200..1000;1,6..12,200..1000&display=swap"
        rel="stylesheet">
    <link
        href="https://fonts.googleapis.com/css2?family=Noto+Sans+Mono:wght@100..900&family=Nunito+Sans:ital,opsz,wght@0,6..12,200..1000;1,6..12,200..1000&display=swap"
        rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/hanzi-writer@3.5/dist/hanzi-writer.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@200..900&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Ma+Shan+Zheng&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=ZCOOL+QingKe+HuangYou&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Zhi+Mang+Xing&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Long+Cang&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Courier+Prime:ital,wght@0,400;0,700;1,400;1,700&display=swap"
        rel="stylesheet">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Stories</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/darkmode.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/flashcard.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/contextmenu.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/hamburger.css') }}">
    <!-- <script src="{{ url_for('static', filename='js/perlin.js') }}"></script> -->
    <script src="{{ url_for('static', filename='js/plotter_better.js') }}"></script>
    <style id="dynamic-styles">

    </style>
    <style>
        @font-face {
            font-family: 'Kaiti';
            src: url("{{ url_for('static', filename='fonts/Kaiti.ttf') }}") format('truetype');
            font-weight: normal;
            font-style: normal;
        }

        body {
            font-family: 'Kaiti', sans-serif;
            padding: 0;
            margin: 0;
        }
        
        h1 {
            text-align: center;
        }

        #title {
            font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
            font-size: 3em;
            margin-bottom: 10px;
        }

        #flashcard_character,
        #flashcard_plotter {
            font-family: 'Kaiti', sans-serif;
        }

        label {
            font-size: 1.2em;
        }

        textarea {
            width: 30vw;
            height: 30vh;
            padding: 10px;
            font-size: 1.5em;
            resize: none;
            display: block;
            border: 2px solid #161616;
        }

        textarea.darkmode {
            border: 2px solid #c2c2c2;
        }


        textarea.darkmode::selection {
            background-color: #dab0db;
            color: #242424;
        }

        .main-container {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding-top: 3%;
            width: 100%;
            position: relative;
        }

        #input-container {
            flex: 0 0 20%;
            align-self: flex-start;
            background: #f8f8f8;
            padding: 20px;
            min-width: min(500px, 90vw);
            max-width: 20%;
        }

        #input-container.darkmode {
            background: #202020;
        }

        #stories-option {
            background: #eecce552;
            padding: 20px;
        }

        #stories-option.darkmode {
            background: #eecce522;
        }
      
        
        #plottersWrapper {
            width: 40%;
            overflow-x: hidden;
            overflow-y: auto;
        }

        #plotters {
            width: calc(100%-80px);
            padding: 60px;
            margin: 40px 40px;
            font-size: 1.1em;
            resize: none;
            display: block;
            background: #eee;
            position: relative;
            box-sizing: content;
        }

        @media (max-width: 1366px) {
            .main-container {
                flex-direction: column;
                align-items: center;
            }   

            #input-container,
            #plottersWrapper {
                flex: 0 0 90%;
                padding: 20px;
                width: 90%;
                max-width: 90%;
                min-width: unset;
                align-self: center;
            }
        }

        #translationBox {
            width: 14vw;
            padding: 20px;
            margin: 0px;
            font-size: 1.7em;
            resize: none;
            position: absolute;
            right: 40px;
            background: #f8f8f8;
            /* transform: translateX(90%); */
            color: rgb(32, 32, 32);
        }

        #translationBox.darkmode {
            background: #292929;
            color: rgb(158, 158, 158);
        }

        #plotters.darkmode {
            background: #1b1b1b;
            color: rgb(206, 206, 206);
        }


        .darkmode {
            color: rgb(236, 236, 236);
            border-color: rgb(100, 100, 100);
        }

        #plotters.empty {
            background: transparent;
        }

        @media screen and (max-width: 768px) {
            textarea {
                width: 90vw;
            }

            
            #translationBox {
                width: 50%;
                padding: 20px;
                margin: 0px;
                font-size: 1.1em;
                resize: none;
                position: absolute;
                right: 40px;
                background: #f8f8f8;
                /* transform: translateX(90%); */
                color: rgb(32, 32, 32);
            }

        }

        .button {
            padding: 10px 20px;
            background-color: #c2c2c2;
            color: rgb(20, 20, 20);
            cursor: pointer;
            transition: background-color 0.3s;
            border-radius: 0;
            user-select: none;
            display: block;
            margin-top: 10px;
            width: fit-content;
        }

        .button.darkmode {
            background-color: #343434;
            color: rgb(206, 206, 206);
        }


        .button:active {
            background-color: #a0b3a1;
        }

        .button.clicked {
            background-color: #ffe341;
            transition: background-color 0s;
            color: rgb(31, 31, 31);
        }

        .option-container {
            margin: 10px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #hanziCount {
            margin-top: 10px;
            right: 0;
        }

        .myslider {
            -webkit-appearance: none;
            /* width: 200px; */
            width: 100%;    
            background: transparent;
        }

        .myslider::-webkit-slider-thumb {
            -webkit-appearance: none;
            border: none;
            height: 16px;
            width: 16px;
            background: black;
            margin-top: -6px;
            cursor: pointer;
        }


        .myslider.darkmode::-webkit-slider-thumb {
            background: rgb(124, 124, 124);
        }

        .myslider::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #ddd;
            border: none;
        }

        .myslider.darkmode::-webkit-slider-runnable-track {
            background: #464646;
        }

        .myslider:focus {
            outline: none;
        }

        canvas.darkmode {
            background-color: transparent;
        }

        .latin {
            /* opacity: 0.65; */
        }

        span.darkmode {
            background-color: transparent;
        }

        .plotterContainer {
            /* padding-top: 30px; */
        }

        span.darkmode {
            background-color: transparent;
        }

        div.darkmode {
            background-color: transparent;
        }

        .hidden {
            visibility: hidden;
        }

        .pinyinLabel {
            font-family: 'Noto Sans Mono', monospace;
            font-size: 0.6em;
        }

        .pinyinLabel:hover {
            cursor: default;
        }

        .pinyinLabelColor:hover {
            cursor: default;
            background-color: #7878787d;
        }

        .line-wrapper {
            margin-top: 0px;
            background: transparent;
        }

        .line-wrapper.darkmode {
            background: transparent;
        }

        .line-wrapper:hover {
            background: #e0e0e0;
        }


        .line-wrapper.darkmode:hover {
            background: #2b2b2b;
        }

        .optionLabel {
            opacity: 0.7;
            min-width: 130px;
        }

        #storyList {
            width: 100%;
        }

        #storyList {
            z-index: 11101;
        }

        .custom-select {
            padding: 5px;
            border-radius: 0;
            font-family: 'Noto Sans Mono', monospace;
            border: 2px solid #4646465d;
            -webkit-border-radius: 0;
            -moz-border-radius: 0;
            z-index: 10;
        }

        .custom-select.darkmode {
            border: 2px solid #666666;
        }   

        .custom-select:focus {
            outline: none;
            box-shadow: none;
            border-color: inherit;
        }

        .custom-select option {
            border-radius: 0;
            opacity: 0.7;
            -webkit-border-radius: 0;
            -moz-border-radius: 0;
        }

        .custom-select {
            position: relative;
            cursor: pointer;
            z-index: 100;
        }

        .custom-select {
            /* border: 0; */
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .custom-select::after {
            content: '\2BC8';
            width: 1em;
            max-width: 1em;
        }

        .custom-select.open::after {
            content: '\25BC';
            width: 1em;
            max-width: 1em;
        }

        .options {
            display: none;
            position: absolute;
            width: 100% ;
            top: 100%;
            left: -2px;
            right: 0;
            border: 2px solid #ccc;
            background: white;
        }

        .options.darkmode {
            background: rgb(20, 20, 20);
            border: 2px solid #666666;
        }

        .custom-select.open .options {
            display: block;
        }

        .option {
            padding: 5px;
        }

        .option:hover {
            background-color: #d6d6d6;
        }

        .option.darkmode:hover {
            background-color: #303030;
        }

        .color-pair {
            display: flex;
            gap: 4px;
            border: 0;
        }

        .story-option {
            display: flex;
            gap: 4px;
            border: 0;
        }

        .color-square {
            width: 45px;
            height: 15px;
            border: 0;
            border-radius: 9px;
        }

        #fontList {
            z-index: 1110;
        }


        .chinese-text {
            font-family: "Noto Sans Mono", monospace;
            font-family: "Noto Serif SC", serif;
        }

        .chinese-text-desktop:hover {
            background-color: #cecece;
            cursor: pointer;
        }

        .chinese-text-desktop.darkmode:hover {
            background-color: #484848;
        }

        .story-title {
            text-align: center;
            color: #fa1111;

        }

        @keyframes glitch {
            0% { transform: translate(0); }
            20% { transform: translate(-2px, 2px); }
            40% { transform: translate(2px, -2px); }
            60% { transform: translate(-2px, -2px); }
            80% { transform: translate(2px, 2px); }
            100% { transform: translate(0); }
        }
        
        @keyframes rainbow {
            0% { color: #444; }
            50% { color: #800; }
            100% { color: #444; }
        }

        @media (max-width: 768px) {
            .option-container:has(#dimsSlider),
            .option-container:has(#paddingSlider) {
                display: none;
            }
/* 
            #plottersContainer {
                width: 100%;
                margin: 0px;
            }

            #plotters {
                width: 100%;
                padding: 10px;
                margin: 20px;
            } */
        }
    </style>
</head>

{% if darkmode %}

<body class="darkmode">
    {% else %}

    <body>
        {% endif %}
        <h1 id="title">Stories</h1>
        <div class="hamburger" id="hamburgerMenu" style="font-size:22px">
            <span></span>
            <span></span>
            <span></span>
        </div>
        <div class="main-container">
            <div id="input-container">
                
                <div class="option-container" id="stories-option">
                    <span class="optionLabel">Stories:</span>
                    <div class="custom-select" id="storyList">
                        <div class="selected-option" id="selectedStory">
                        </div>
                        <div class="options" id="storyOptions">
                        </div>
                    </div>
                </div>
                <!-- <div class="option-container">
                    <span class="optionLabel">Area dims:</span>
                    <span id="dimsValue">60</span>
                    <input type="range" class="myslider" id="dimsSlider" min="20" max="100" step="1" value="60">
                </div>
                <div class="option-container">
                    <span class="optionLabel">Padding:</span>
                    <span id="paddingValue">120</span>
                    <input type="range" class="myslider" id="paddingSlider" min="50" max="400" step="1" value="120">
                </div> -->
                <div class="option-container">
                    <span class="optionLabel">Character size:</span>
                    <span id="sizeValue">50</span>
                    <input type="range" class="myslider" id="sizeSlider" min="30" max="100" step="2" value="50">
                </div>
                <div class="option-container">
                    <span class="optionLabel">Anim speed:</span>
                    <span id="speedValue">2x</span>
                    <input type="range" class="myslider" id="speedSlider" min="0.5" max="4" step="0.1" value="2">
                </div>
                <div class="option-container">
                    <span class="optionLabel">Stroke width:</span>
                    <span id="thicknessValue">10pt</span>
                    <input type="range" class="myslider" id="thicknessSlider" min="1" max="20" step="0.1" value="10">
                </div>
                <div class="option-container">
                    <span class="optionLabel">Stroke noise:</span>
                    <span id="noiseValue">0</span>
                    <input type="range" class="myslider" id="noiseSlider" min="0" max="10" step="0.1" value="0">
                </div>
                <div class="option-container">
                    <span class="optionLabel">Natural:</span>
                    <input type="checkbox" id="naturalCheckbox">
                </div>
                <div class="option-container">
                    <span class="optionLabel">Background:</span>
                    <input type="checkbox" id="backgroundCheckbox">
                    <input type="checkbox" id="backgroundCheckbox2">
                </div>
                <div class="option-container">
                    <span class="optionLabel">Show pinyin:</span>
                    <input type="checkbox" id="pinyinCheckbox">
                </div>
                
                <div class="option-container" id="fonts-option">
                    <span class="optionLabel">Fonts:</span>
                    <div class="custom-select" id="fontList">
                        <div class="selected-option" id="selectedFont">
                            <div class="font-choice">
                                Noto Sans
                            </div>
                        </div>
                        <div class="options" id="fontOptions">
                            <div class="option isfont" data-value="1">
                                <div class="font-choice">
                                    Kaiti
                                </div>
                            </div>
                            <div class="option isfont" data-value="2">
                                <div class="font-choice">
                                    Noto Serif SC
                                </div>
                            </div>
                            <div class="option isfont" data-value="3">
                                <div class="font-choice">
                                    Noto Sans
                                </div>
                            </div>

                        </div>
                    </div>
                </div>

            </div>

            <div id="plottersWrapper" class="empty">
                <div id="plotters" class="empty"></div>
            </div>
        </div>

        <script>
            const inputdecks = {{ decks | tojson | safe }};
            let inputdeck = {{ deck | tojson | safe }};
            let isDarkMode = {{ darkmode | tojson | safe }};
            const username = {{ username | tojson | safe }};
            let dataPerCharacter = {{ dataPerCharacter | tojson | safe }};
            let story = {{ story | tojson | safe }};
            let stories = {{ stories | tojson | safe }};
            // load image from static/images/okhsl.webp
            let okhslImage = new Image();
            okhslImage.src = "{{ url_for('static', filename='images/okhsl.webp') }}";

            let colorCanvas = document.createElement('canvas');
            let colorCtx = colorCanvas.getContext('2d');

            okhslImage.onload = function() {
                colorCanvas.width = okhslImage.width;
                colorCanvas.height = okhslImage.height;
                colorCtx.drawImage(okhslImage, 0, 0);
            };

            function sampleOKHSL(hue, sat, value, alpha=1) {
                hue = Math.max(0, Math.min(1, hue%1));
                sat = Math.max(0, Math.min(1, sat));
                value = Math.max(0, Math.min(1, value));

                let x = Math.floor(hue * (colorCanvas.width - 1));
                let y = Math.floor((1 - value) * (colorCanvas.height - 1));

                let imageData = colorCtx.getImageData(x, y, 1, 1);
                let [r, g, b] = imageData.data;
                r /= 255;
                g /= 255;
                b /= 255;

                let gray = value;

                r = r * sat + gray * (1 - sat);
                g = g * sat + gray * (1 - sat);
                b = b * sat + gray * (1 - sat);

                r = Math.round(r * 255);
                g = Math.round(g * 255);
                b = Math.round(b * 255);

                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            }


        </script>

        <script>
            /*
            function init(){
                const hanziPlotter = new HanziPlotter({
                    character: '籍',
                    dimension: 200,
                    speed: .4,
                    lineThickness: 12,
                    jitterAmp: 1
                });
                document.body.appendChild(hanziPlotter.getCanvas());
                hanziPlotter.draw();
            }

            init();
            */

            let input = document.getElementById('hanziInput');
            let plottersElem = document.getElementById('plotters');
            let plotters = [];
            let isMouseDown = false;
            let selectedDropdownValue = [1, 1, 1];
            let renderFont = 'Noto Serif SC';
            let selectedStoryIndex = 0;
            
            let colorList = [
                '#000',
                '#ddd',
                '#500'
            ];
            
            const backgroundList = [
                '#ddd',
                '#000',
            ];

            const fontList = ['Kaiti', 'Noto Serif SC', 'Noto Sans'];


            function isHanzi(char) {
                return /[\u4e00-\u9fff]/.test(char);
            }

            function populateStoryOptions() {
                const selectedStory = document.getElementById('selectedStory');
                const optionsContainer = document.getElementById('storyOptions');

                // Populate the selected option (default to the first story)
                selectedStory.innerHTML = `
                    <div class="story-option">
                        ${stories[selectedStoryIndex].title}
                    </div>
                `;

                // Clear existing options
                optionsContainer.innerHTML = '';

                // Populate the options
                stories.forEach((story, index) => {
                    const optionDiv = document.createElement('div');
                    optionDiv.className = 'option isstory';
                    optionDiv.setAttribute('data-value', index + 1);
                    optionDiv.innerHTML = `
                        <div class="story-option">
                            ${story.title}
                        </div>
                    `;
                    optionsContainer.appendChild(optionDiv);
                });
            }


            function populateColorOptions() {
                const selectedColor = document.getElementById('selectedPalette');
                const colorOptions = document.getElementById('colorOptions');
                colorOptions.innerHTML = '';

                let colorListC = [...colorList];

                if(isDarkMode){
                    colorListC = [colorList[1], colorList[0], colorList[2]];
                }
                
                selectedColor.innerHTML = `
                    <div class="color-pair">
                        <div class="color-square" style="background-color: ${colorList[0]}"></div>
                    </div>
                `;
                colorList.forEach((color, index) => {
                    const optionDiv = document.createElement('div');
                    optionDiv.className = 'option iscolor';
                    optionDiv.setAttribute('data-value', index + 1);

                    const colorPairDiv = document.createElement('div');
                    colorPairDiv.className = 'color-pair';

                    const colorSquareDiv = document.createElement('div');
                    colorSquareDiv.className = 'color-square';
                    colorSquareDiv.style.backgroundColor = color;

                    colorPairDiv.appendChild(colorSquareDiv);
                    optionDiv.appendChild(colorPairDiv);
                    colorOptions.appendChild(optionDiv);
                });
            }


            async function getPinyinEnglishFor(character) {
                try {
                    const response = await fetch(`./get_simple_char_data?character=${encodeURIComponent(character)}`);
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    const data = await response.json();
                    return data;
                } catch (error) {
                    console.error('Error:', error);
                    return null;
                }
            }
            function isPunctuation(char) {
                return char === "。" || char === "，" || char === "、" || char === "；" || char === "：";
            }

            function remap(value, low1, high1, low2, high2) {
                return low2 + (value - low1) * (high2 - low2) / (high1 - low1);
            }

            // let dimsSlider;
            // let dimsValue;
            // let paddingSlider;
            // let paddingValue;
            let sizeSlider;
            let speedSlider;
            let speedValue;
            let thicknessSlider;
            let thicknessValue;
            let noiseSlider;
            let noiseValue;
            let backgroundCheckbox;
            let backgroundCheckbox2;
            let pinyinCheckbox;
            let naturalCheckbox;


            let rmouseX = 0;
            let rmouseY = 0;
            let mouseX = 0;
            let mouseY = 0;

            let fullInput = '';
            let fullOutputTranslation = '';
            let showAllPinyin = false;

            let titleColors = [
                "hsl(0, 100%, 50%)",
                "hsl(30, 100%, 50%)",
                "hsl(60, 100%, 50%)",
                "hsl(90, 100%, 50%)",
                "hsl(120, 100%, 50%)",
            ]
            let titleColor = '#880000';
            titleColor = '#ff5100';
            let currentHoveredLine = -1;

            function addHoverBehaviorToWrapper(wrapper, lineIndex) {
                let translationBox = document.getElementById('translationBox');
                let canvaswrapper = document.getElementById('plottersWrapper');

                wrapper.addEventListener('mouseenter', function (event) {
                    translationBox.textContent = story.english[lineIndex];
                    setTimeout(() => {
                        currentHoveredLine = lineIndex;
                    }, 1110);

                    document.querySelectorAll('.pinyinLabel.line_' + lineIndex).forEach((el) => {
                        el.classList.remove('hidden');
                    });

                    if(translationBox.textContent.length === 0){
                        return;
                    }
                    translationBox.classList.remove('hidden');
                    // let canvaswrapperposy = canvaswrapper.getBoundingClientRect().top;
                    // let wrapperposy = wrapper.getBoundingClientRect().top - canvaswrapperposy + 222;
                    // translationBox.style.top = wrapperposy + 'px';

                    // translationBox.style.position = 'absolute';
                    // let verticalscrolly = window.scrollY;
                    let translationboxwidth = translationBox.offsetWidth;
                    // translationBox.style.left = event.clientX + 20 + 'px';
                    // translationBox.style.top = window.scrollY + event.clientY + 20 + 'px';
                    // // check if out of bounds
                    // if (event.clientX + translationboxwidth > window.innerWidth) {
                    //     translationBox.style.left = event.clientX - translationboxwidth + 'px';
                    // }
                    // if(event.clientX - translationboxwidth < 0){
                    //     translationBox.style.left = 0;
                    // }

                    if(isMobileOrTablet()){
                        translationBox.style.position = 'absolute';
                        translationBox.style.left = 20 + 'px';
                        translationBox.style.top = window.scrollY + 20 + 'px';
                        // translationBox.style.transform = "translateX(-" + translationboxwidth + ")";
                    }
                });

                wrapper.addEventListener('mousemove', function (event) {
                    let canvaswrapperposy = canvaswrapper.getBoundingClientRect().top;
                    let wrapperposy = wrapper.getBoundingClientRect().top - canvaswrapperposy + 222;
                    // translationBox.style.top = wrapperposy + 'px';

                    // translationBox.style.position = 'absolute';
                    // translationBox.style.left = event.clientX + 20 + 'px';
                    // translationBox.style.top = window.scrollY + event.clientY + 20 + 'px';
                    let translationboxwidth = translationBox.offsetWidth;
                    // // check if out of bounds
                    // if (event.clientX + translationboxwidth > window.innerWidth) {
                    //     translationBox.style.left = event.clientX - translationboxwidth + 'px';
                    // }
                    // if(event.clientX - translationboxwidth < 0){
                    //     translationBox.style.left = 0;
                    // }

                    if(isMobileOrTablet()){
                        translationBox.style.position = 'absolute';
                        translationBox.style.left = 20 + 'px';
                        translationBox.style.top = window.scrollY + 20 + 'px';
                        // translationBox.style.transform = "translateX(-" + translationboxwidth + ")";
                    }
                });

                wrapper.addEventListener('mouseleave', function () {
                    translationBox.classList.add('hidden');
                    currentHoveredLine = -1;
                    if (!showAllPinyin) {
                        document.querySelectorAll('.pinyinLabel.line_' + lineIndex).forEach((el) => {
                            el.classList.add('hidden');
                        });
                    }
                });
            }
            function applyPinyinVisibility() {
                document.querySelectorAll('.pinyinLabel').forEach(element => {
                    if (showAllPinyin) {
                        element.classList.remove('hidden');
                    }
                    else {
                        element.classList.add('hidden');
                    }
                });
            }

            function applyInitialStyles(bubbleobj) {
                let bubble = bubbleobj.bubble;
                let x = 0;
                let y = 0;
                const bubbleWidth = bubble.offsetWidth;
                const bubbleHeight = bubble.offsetHeight;
                const windowWidth = window.innerWidth;
                const windowHeight = window.innerHeight;
                const close = document.createElement('div');
                close.setAttribute('id', 'translation-bubble-close');
                close.style.position = 'absolute';
                close.style.width = '16px';
                close.style.height = '16px';
                close.style.right = '2px';
                close.style.top = '2px';
                close.style.background = '#ffffff88';
                close.style.boxShadow = '0 2px 4px rgba(0,0,0,0.3)';
                close.style.borderRadius = '50%';
                close.style.cursor = 'pointer';
                close.style.zIndex = '333';
                close.style.opacity = '0.0';
                close.style.transition = 'opacity 0.3s ease';
                close.addEventListener('click', function() {
                    removeBubbleFromDOM(bubbleobj);
                    activeBubbles = activeBubbles.filter(b => b !== bubbleobj);
                    bubbleobj.removed = true;
                });

                bubble.appendChild(close);
                bubbleobj.closebutton = close;

                const documentClickHandler = function(event) {
                    if (!bubble.contains(event.target)) {
                        if(hasOpenBubbles){
                            removeBubbleFromDOM(bubbleobj);
                            activeBubbles = activeBubbles.filter(b => b !== bubbleobj);
                            bubbleobj.removed = true;
                            document.body.removeEventListener('click', documentClickHandler);
                            hasOpenBubbles = false;
                        }
                    }
                };
                document.body.addEventListener('click', documentClickHandler);
                bubbleobj.documentClickHandler = documentClickHandler;
            }


            function applyInitialPos(bubbleobj) {
                let bubble = bubbleobj.bubble;
                let x = 0;
                let y = 0;
                const bubbleWidth = bubble.offsetWidth;
                const bubbleHeight = bubble.offsetHeight;
                const windowWidth = window.innerWidth;
                const windowHeight = window.innerHeight;

                const padding = 50;
                x = rmouseX + window.scrollX - bubbleWidth / 2;
                y = rmouseY + window.scrollY - bubbleHeight - 15;

                if(x + bubbleWidth > window.scrollX + windowWidth - padding)
                    x = window.scrollX + windowWidth - padding - bubbleWidth;
                if(x < window.scrollX + padding)
                    x = window.scrollX + padding;
                if(y + bubbleHeight > window.scrollY + windowHeight - padding)
                    y = window.scrollY + windowHeight - padding - bubbleHeight;
                if(y < window.scrollY + padding)
                    y = window.scrollY + padding;


                bubble.style.left = `${x}px`;
                bubble.style.top = `${y}px`;
            }

            let initializeStyle = false;
            let activeBubbles = [];
            let hasOpenBubbles = false;
            
            class Bubble {
                constructor(domelement) {
                    this.bubble = domelement;
                    this.closebutton = null;
                    this.draggablearea = null;
                    this.dragged = false;
                    this.overdragged = false;
                    this.timeoutId = null;
                    this.fadeId = null;
                    this.mouseover = false;
                }

                setPos(x, y) {
                    this.bubble.style.left = `${x}px`;
                    this.bubble.style.top = `${y}px`;
                    const bubbleWidth = this.bubble.offsetWidth;
                    const bubbleHeight = this.bubble.offsetHeight;
                    // whiteedge has to be moved because it's not a child of bubble, because it has to be behind (z-index stuff)
                }
            }

            function makeAIBubble(prompt){
                // removeBubbleFromDOM();

                let style = null;
                if(!initializeStyle) {
                    style = document.createElement('style');
                    style.textContent = `
                        .translation-bubble, .translation-bubble * {
                            user-select: text; /* Allows text to be selected inside the bubble */
                            color: rgba(10,10,10,1.0); /* Ensure text color is consistent */
                            display: inline-block; /* Treat inline elements like block elements */
                            white-space: nowrap; /* Prevents the collapse of whitespace */
                            text-wrap: balance; /* Balance text wrapping */
                        }
                        .translation-bubble::selection, .translation-bubble *::selection {
                            background: #FFD700; /* Gold background for the bubble */
                            color: #000; /* Black text for the bubble */
                        }
                    `;
                    document.head.appendChild(style);
                    initializeStyle = true;
                }

                let bubblediv = document.createElement('div');
                bubblediv.setAttribute('id', 'translation-bubble');
                bubblediv.className = 'translation-bubble';
                // let lines = request.translatedText.split('\n').map(line => {
                //     line = line.trim();
                //     if (line.startsWith('*')) {
                //         line = `<i>${line.slice(1).trim()}</i>`;
                //     }
                //     line = line.split('. ').join('.<br>');
                //     line = line.split('." ').join('."<br>');
                //     return line;
                // });

                // create a text container
                let bubbletext = document.createElement('div');
                bubbletext.className = 'translation-bubble-text';
                bubbletext.innerHTML = "<span style='font-style: italic; font-size: 0.8em;'>thinking...</span> ";
                // bubbletext.innerHTML = prompt;

                // bubblediv.innerHTML = request.translatedText;
                bubblediv.appendChild(bubbletext);
                document.body.appendChild(bubblediv);

                setTimeout(() => {
                    hasOpenBubbles = true;
                }, 1000);

                let bubble = new Bubble(bubblediv)
                bubble.bubbletext = bubbletext;
                activeBubbles.push(bubble);
                
                bubblediv.style.position = 'absolute';
                bubblediv.style.padding = '18px 24px';
                bubblediv.style.backgroundColor = 'rgba(255,255,255, 0.75)';
                bubblediv.style.border = 'none';
                bubblediv.style.borderRadius = '10px';
                bubblediv.style.boxShadow = '0 4px 6px rgba(0,0,0,0.1)';
                bubblediv.style.backdropFilter = 'blur(5px)';
                bubblediv.style.zIndex = '3666';
                bubblediv.style.color = 'rgba(9,9,9,1.0)';
                bubblediv.style.fontSize = '16px';
                bubblediv.style.font = 'Roboto, sans-serif';

                bubbletext.style.cssText = 'scrollbar-width: none; max-height: 600px; max-width: 500px; overflow-y: scroll; padding: 6px 0px;';
                // bubbletext.style.overflowY = bubbletext.scrollHeight > bubbletext.clientHeight ? 'scroll' : 'hidden';

                applyInitialPos(bubble);
                if(activeBubbles.length > 0) {
                    let bubbleobj = activeBubbles[activeBubbles.length - 1];
                    let bubble = bubbleobj.bubble;

                    const documentClickHandler = function(event) {
                        if (!bubble.contains(event.target)) {
                            if(hasOpenBubbles){
                                removeBubbleFromDOM(bubbleobj);
                                activeBubbles = activeBubbles.filter(b => b !== bubbleobj);
                                bubbleobj.removed = true;
                                document.body.removeEventListener('click', documentClickHandler);
                                hasOpenBubbles = false;
                            }
                        }
                    };
                    document.body.addEventListener('click', documentClickHandler);
                    bubbleobj.documentClickHandler = documentClickHandler;


                    // applyInitialStyles(bubble);
                    // addBubbleInteractions(bubble);
                    // checkMouseOver(bubble);
                }

                fetchStream(prompt, bubble);

                // setTimeout(() => {
                //     let bubble = activeBubbles[activeBubbles.length - 1];
                //     removeBubbleFromDOM(bubble);
                //     activeBubbles = activeBubbles.filter(b => b !== bubble);
                //     bubble.removed = true; // Mark the object as removed
                // }, 2000);
            }

            let timeouts = [];

            function addBubbleInteractions(bubbleobj) {

                let bubble = bubbleobj.bubble;
                bubble.addEventListener('mousedown', function(event) {
                    event.stopPropagation();  // Prevent the bubble from closing when clicked
                }, false);

                const draggableArea = document.createElement('div');
                // set id
                draggableArea.setAttribute('id', 'translation-bubble-draggable');
                draggableArea.style.width = '50px';
                draggableArea.style.height = '14px';
                draggableArea.style.position = 'absolute';
                draggableArea.style.top = '2px';
                draggableArea.style.left = '50%';
                draggableArea.style.transform = 'translateX(-50%)';
                draggableArea.style.cursor = 'move';
                draggableArea.style.background = '#ffffff88';
                draggableArea.style.boxShadow = '0 2px 4px rgba(0,0,0,0.3)';
                draggableArea.style.borderRadius = '4px';
                draggableArea.style.cursor = 'pointer';
                draggableArea.style.zIndex = '333';
                draggableArea.style.opacity = '0.0';
                draggableArea.style.transition = 'opacity 0.3s ease';
                bubble.appendChild(draggableArea);

                bubbleobj.draggablearea = draggableArea;

                draggableArea.addEventListener('mousedown', function(event) {
                    bubbleobj.dragged = true;
                    offsetX = (event.clientX + window.scrollX - parseInt(bubble.style.left, 10));
                    offsetY = (event.clientY + window.scrollY - parseInt(bubble.style.top, 10));
                    // event.preventDefault(); // Prevent text selection
                });
                
                draggableArea.addEventListener('mouseover', function(event) {
                    let close = bubbleobj.closebutton;
                    let drag = bubbleobj.draggablearea;
                    close.style.opacity = '1.0';
                    drag.style.opacity = '1.0';
                    bubbleobj.overdragged = true;
                    console.log('overdragged');
                });

                draggableArea.addEventListener('mouseout', function(event) {
                    let close = bubbleobj.closebutton;
                    let drag = bubbleobj.draggablearea;
                    close.style.opacity = '0.0';
                    drag.style.opacity = '0.0';
                    bubbleobj.overdragged = false;
                });

                document.addEventListener('mousemove', function(event) {
                    if (bubbleobj.dragged) {
                        bubbleobj.setPos(
                            event.clientX + window.scrollX - offsetX,
                            event.clientY + window.scrollY - offsetY
                        );
                    }
                });
                
                document.addEventListener('mouseup', function() {
                    bubbleobj.dragged = false;
                    checkMouseOver(bubbleobj);
                });


                document.addEventListener('mousemove', function(event) {
                    let x = event.clientX + window.scrollX;
                    let y = event.clientY + window.scrollY;
                    mouseX = x;
                    mouseY = y;
                    checkMouseOver(bubbleobj);
                });
            }

            document.addEventListener('mousemove', function(event) {
                rmouseX = event.clientX;
                rmouseY = event.clientY;
            });


            function checkMouseOver(bubbleobj){
                let x = mouseX;
                let y = mouseY;
                let close = bubbleobj.closebutton;
                let drag = bubbleobj.draggablearea;
                let bubble = bubbleobj.bubble;
                let bubbleX = parseInt(bubble.style.left, 10);
                let bubbleY = parseInt(bubble.style.top, 10);
                let bubbleWidth = bubble.offsetWidth;
                let bubbleHeight = bubble.offsetHeight;
                if(x > bubbleX && x < bubbleX + bubbleWidth && y > bubbleY && y < bubbleY + bubbleHeight) {
                    close.style.opacity = '1.0';
                    drag.style.opacity = '1.0';
                    bubbleobj.mouseover = true;
                    clearTimeout(bubbleobj.fadeId);
                    bubbleobj.fadeId = null;
                    // after one second fade it back to 0.0
                    if(!bubbleobj.dragged){
                        if(!bubbleobj.fadeId){
                            bubbleobj.fadeId = setTimeout(() => {
                                if(!bubbleobj.overdragged){
                                    close.style.opacity = '0.0';
                                    drag.style.opacity = '0.0';
                                }
                            }, 1000);
                        }
                    }
                    if (bubbleobj.timeoutId) {
                        clearTimeout(bubbleobj.timeoutId);
                        bubbleobj.timeoutId = null;      
                    }
                } else {
                    close.style.opacity = '0.0';
                    drag.style.opacity = '0.0';
                    if(bubbleobj.mouseover)
                        resetTimeout(bubbleobj);
                    bubbleobj.mouseover = false;
                }
            }

            function resetTimeout(bubbleobj) {
                if (bubbleobj.timeoutId) {
                    clearTimeout(bubbleobj.timeoutId);
                    bubbleobj.timeoutId = null;            
                }
                bubbleobj.timeoutId = setTimeout(() => {
                    if (!bubbleobj.removed) {
                        removeBubbleFromDOM(bubbleobj);
                        activeBubbles = activeBubbles.filter(b => b !== bubbleobj);
                        bubbleobj.removed = true; // Mark the object as removed
                    }
                }, 3333);
            }

            function removeBubbleFromDOM(bubbleobj) {
                // Animate opacity from 1 to 0
                document.removeEventListener('click', bubbleobj.documentClickHandler);
                bubbleobj.bubble.style.transition = 'opacity 0.2';
                // bubbleobj.closebutton.style.transition = 'opacity 0.2';
                // bubbleobj.draggablearea.style.transition = 'opacity 0.2';

                bubbleobj.bubble.style.opacity = '0';
                // bubbleobj.closebutton.style.opacity = '0';
                // bubbleobj.draggablearea.style.opacity = '0';

                // Set a timeout to remove the elements from the DOM after the animation
                setTimeout(() => {
                    bubbleobj.bubble.parentNode.removeChild(bubbleobj.bubble);
                    // bubbleobj.closebutton.parentNode.removeChild(bubbleobj.closebutton);
                    // bubbleobj.draggablearea.parentNode.removeChild(bubbleobj.draggablearea);
                }, 200);  // Delay of 1000 milliseconds
            }

            function getStory(index, func=null) {
                fetch(`./get_story/${index}`)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error('Network response was not ok');
                        }
                        return response.json();
                    })
                    .then(data => {
                        console.log(data)
                        story = data.story;
                        dataPerCharacter = data.char_data;
                        if(func) {
                            func();
                        }
                    })
                    .catch(error => {
                        console.error('There was a problem with the fetch operation:', error.message);
                    });
            }

            function setupDropdowns() {
                
                let dropdowns = [
                    {
                        elem: document.getElementById('storyList'),
                        childquery: '.story-option',
                        childquery2: '.isstory',
                        selected: document.getElementById('selectedStory'),
                    },
                    {
                        elem: document.getElementById('fontList'),
                        childquery: '.font-choice',
                        childquery2: '.isfont',
                        selected: document.getElementById('selectedFont'),
                    }
                ]

                dropdowns.forEach((drop, idx) => {

                    drop.elem.addEventListener('click', function(event) {
                        event.stopPropagation();
                        drop.elem.classList.toggle('open');
                    });
                    let optionsElemens = document.querySelectorAll(drop.childquery2);
                    optionsElemens.forEach(option => {
                        console.log(option);
                        option.addEventListener('click', function() {
                            const value = parseInt(option.dataset.value);
                            selectedDropdownValue[idx] = value;
                            const row = option.querySelector(drop.childquery).cloneNode(true);
                            drop.selected.innerHTML = '';
                            drop.selected.appendChild(row);
                            if(drop.elem.id == 'storyList') {
                                story = getStory(value, redrawPlotters);
                                selectedStoryIndex = value;
                            }
                            else if(drop.elem.id == 'fontList') {
                                renderFont = fontList[value - 1];
                                naturalCheckbox.checked = false;
                                redrawPlotters();
                            }
                            else{
                                redrawPlotters();
                            }
                        });
                    });
                    document.addEventListener('click', function() {
                        drop.elem.classList.remove('open');
                    });
                });

                const dropdownIndex = 1;
                const optionValue = 1;
                const option = document.querySelector(`${dropdowns[dropdownIndex].childquery2}[data-value="${optionValue}"]`);
                if (option) {
                    selectedDropdownValue[dropdownIndex] = optionValue;
                    const row = option.querySelector(dropdowns[dropdownIndex].childquery).cloneNode(true);
                    dropdowns[dropdownIndex].selected.innerHTML = '';
                    dropdowns[dropdownIndex].selected.appendChild(row);
                    dropdowns[dropdownIndex].elem.classList.remove('open');
                    story = getStory(optionValue, redrawPlotters);
                }

            }
            
            document.addEventListener("DOMContentLoaded", function () {
                // dimsSlider = document.getElementById('dimsSlider');
                // paddingSlider = document.getElementById('paddingSlider');
                speedSlider = document.getElementById('speedSlider');
                sizeSlider = document.getElementById('sizeSlider');
                thicknessSlider = document.getElementById('thicknessSlider');
                noiseSlider = document.getElementById('noiseSlider');

                // dimsValue = document.getElementById('dimsValue');
                // paddingValue = document.getElementById('paddingValue');
                speedValue = document.getElementById('speedValue');
                sizeValue = document.getElementById('sizeValue');
                thicknessValue = document.getElementById('thicknessValue');
                noiseValue = document.getElementById('noiseValue');

                backgroundCheckbox = document.getElementById('backgroundCheckbox');
                backgroundCheckbox2 = document.getElementById('backgroundCheckbox2');
                pinyinCheckbox = document.getElementById('pinyinCheckbox');
                naturalCheckbox = document.getElementById('naturalCheckbox');

                plottersWrapper = document.getElementById('plottersWrapper');
                plottersElem = document.getElementById('plotters');

                noiseValue.textContent = noiseSlider.value;
                pinyinCheckbox.checked = showAllPinyin;
                populateStoryOptions();
                // populateColorOptions();
                // redrawPlotters();
                // updateCount();
                setupDropdowns();
                
                if(!isMobileOrTablet()){
                    // document.getElementById('plotters').style.width = dimsSlider.value + '%';
                    // dimsSlider.addEventListener('input', function () {
                    //     dimsValue.textContent = this.value;
                    //     document.getElementById('plotters').style.width = this.value + '%';
                    // });

                    // document.getElementById('plotters').style.padding = paddingSlider.value + 'px';
                }

                // paddingSlider.addEventListener('input', function () {
                //     paddingValue.textContent = this.value;
                //     document.getElementById('plotters').style.padding = this.value + 'px';
                // });

                speedSlider.addEventListener('change', function() {
                    speedValue.textContent = this.value + 'x';
                    redrawPlotters();
                });

                sizeSlider.addEventListener('change', function() {
                    sizeValue.textContent = this.value;
                    redrawPlotters();
                });

                thicknessSlider.addEventListener('change', function() {
                    thicknessValue.textContent = this.value + 'pt';
                    if (!plottersElem.classList.contains('empty')) {
                        redrawPlotters();
                    }
                });

                noiseSlider.addEventListener('change', function() {
                    noiseValue.textContent = this.value;
                    if (!plottersElem.classList.contains('empty')) {
                        redrawPlotters();
                    }
                });

                backgroundCheckbox.addEventListener('input', function() {
                    if (!plottersElem.classList.contains('empty')) {
                        redrawPlotters();
                    }
                });

                backgroundCheckbox2.addEventListener('input', function() {
                    if (!plottersElem.classList.contains('empty')) {
                        redrawPlotters();
                    }
                });

                naturalCheckbox.addEventListener('change', function() {
                    if (!plottersElem.classList.contains('empty')) {
                        redrawPlotters();
                    }
                });

                pinyinCheckbox.addEventListener('change', function() {
                    showAllPinyin = this.checked;
                    applyPinyinVisibility();
                });

                plottersElem.addEventListener('mousedown', function(e) {
                    // e.preventDefault();
                });
            });


            document.addEventListener("mousedown", function () {
                isMouseDown = true;
            });

            document.addEventListener("mouseup", function () {
                isMouseDown = false;
            });

            document.addEventListener("keydown", function (e) {
                if (e.key === 'q') {
                    showAllPinyin = !showAllPinyin;
                    applyPinyinVisibility();
                }
            });

            document.addEventListener("mousemove", function (e) {
                if (isMouseDown) {
                    const plotterIndex = e.target.dataset.plotterIndex;
                    if (plotterIndex !== undefined) {
                        plotters[plotterIndex].plotter.canvas.click();
                    }
                }
            });

            function fetchStream(prompt, bubble) {
                console.log(prompt);
                fetch("/api/openaiexplain", { 
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        model: "gpt-4o",
                        messages: [
                            {"role": "system", "content": "I am a genius Chinese language instructor."},
                            {"role": "user", "content": prompt}
                        ],
                        max_tokens: 400,
                        stream: true
                    })
                })
                .then(response => {
                    const reader = response.body.getReader();
                    let streamText = '';
                    let isFirstChunk = true;  // Flag to check if it's the first chunk

                    return reader.read().then(function processText({ done, value }) {
                        if (done) {
                            // console.log('sending last chunk');
                            // chrome.tabs.sendMessage(tabId, {
                            //     type: "sendTranslationEnd"
                            // });
                            // storeTranslation(fullInput, fullOutputTranslation);
                            return streamText;
                        }
                        streamText += new TextDecoder("utf-8").decode(value, {stream: true});

                        let lastNewline = streamText.lastIndexOf('\n');
                        if (lastNewline > -1) {
                            let messages = streamText.substring(0, lastNewline).split('\n');
                            messages.forEach(message => {
                                if (message.startsWith('data: ')) {
                                    message = message.substring(6); // Remove 'data: ' prefix
                                    // if message is text, just print it
                                    if(!message.startsWith('[DONE]')) {
                                        try {
                                            const data = JSON.parse(message);
                                            if (data.choices) {
                                                data.choices.forEach(choice => {
                                                    if (choice.delta && choice.delta.content) {
                                                        if (isFirstChunk) {
                                                            // console.log('sending first chunk')
                                                            bubble.bubbletext.innerHTML = choice.delta.content;
                                                            isFirstChunk = false;  // Update the flag after sending the first message
                                                        } else {
                                                            let chunk = choice.delta.content;
                                                            fullOutputTranslation += chunk;
                                                            bubble.bubbletext.innerHTML += chunk;
                                                        }
                                                    }
                                                });
                                            }
                                        } catch (error) {
                                            console.log('Received non-JSON or special message:', error);
                                        }
                                    }
                                }
                            });
                            streamText = streamText.substring(lastNewline + 1);
                        }
                        return reader.read().then(processText);
                    });
                })
                .catch(err => console.error('Error:', err));
            }


            function renderPlottersToDOM(plotterElement, plotters, showAllPinyin, colors, size, dataPerCharacter, currentLines, storyTitleElem) {
                plotterElement.innerHTML = '';
                
                
                plotterElement.dataset.plotters = plotters;

                let translationBox = document.createElement('div');
                translationBox.setAttribute('id', 'translationBox');
                translationBox.classList.add('hidden');
                //plotterElement.appendChild(translationBox);
                // let plottersWrapper = document.getElementById('plottersWrapper');
                // plottersWrapper.appendChild(translationBox);
                document.body.appendChild(translationBox);

                let currentLineIndex = null;
                let currentWrapper = null;
                let useTextRendering = !naturalCheckbox.checked;

                if (useTextRendering) { 
                    storyTitleElem.style.fontSize = size / 40 + 'em';
                    // plotterElement.appendChild(storyTitleElem);
                }
                else{
                    storyTitleElem.style.fontSize = size / 35 + 'em';
                    let text = storyTitleElem.textContent;
                    storyTitleElem.innerHTML = "";
                    // create plotters for each char in title
                    let refplot = plotters[0];
                    let numLines = currentLines.length;
                    for (let i = 0; i < text.length; i++) {
                        let char = text[i];
                        
                    }
                }

                plotters.forEach((plotterinfo, index) => {
                    let plotter = plotterinfo.plotter;
                    let lineIndex = plotterinfo.lineIndex;

                    let isTitle = lineIndex === -1;

                    if (lineIndex !== currentLineIndex) {
                        currentWrapper = document.createElement('div');
                        currentWrapper.className = 'line-wrapper';
                        if(isDarkMode){
                            currentWrapper.classList.add('darkmode');
                        }
                        if(isTitle){
                            currentWrapper.style.textAlign = 'center';
                        }
                        currentWrapper.dataset.lineIndex = lineIndex;
                        plotterElement.appendChild(currentWrapper);
                        currentLineIndex = lineIndex;

                        addHoverBehaviorToWrapper(currentWrapper, lineIndex);
                    }

                    if (plotter) {
                        let char = plotterinfo.char;
                        if (useTextRendering) { 
                            
                            let charContainer = document.createElement('div');
                            charContainer.style.display = 'inline-block';
                            charContainer.style.textAlign = 'center';
                            charContainer.classList.add('plotterContainer');

                            let pinyinElement = document.createElement('div');
                            pinyinElement.classList.add('pinyinLabel');
                            pinyinElement.classList.add('line_' + lineIndex);
                            pinyinElement.style.fontSize = (size / 150) + 'em'; // Adjust this ratio as needed
                            pinyinElement.style.height = '20px';
                            pinyinElement.style.userSelect = 'none';
                            if (!showAllPinyin) {
                                pinyinElement.classList.add('hidden');
                            }

                            let charSpan = document.createElement('span');
                            charSpan.classList.add('chinese-text');
                            charSpan.style.fontFamily = renderFont;
                            charSpan.textContent = char;
                            charSpan.style.fontSize = size / 50 + 'em';
                            charSpan.style.color = colors[0];

                            charSpan.addEventListener('click', function() {
                                let prompt = 'explain to me briefly the function of the word/character ' + char + ' in the context of the sentence: "' + currentLines[lineIndex] + '". If it belongs to a word alongside other characters, please explain the word as a whole. Be brief, don\'t repeat the sentence and dont say "in the context..". If the char is not in the sentence, dont mention that fact, pretend its there.';
                                
                                if(lineIndex !== currentHoveredLine){
                                    return;
                                }
                                makeAIBubble(prompt);
                                translationBox.classList.add('hidden');
                            });

                            if(!isMobileOrTablet()){
                                charSpan.classList.add('chinese-text-desktop')
                            }
                            if(isDarkMode){
                                charSpan.classList.add('darkmode')
                            }

                            if(isTitle){
                                charSpan.style.fontSize = size / 30 + 'em';
                                charSpan.style.color = sampleOKHSL((selectedStoryIndex-1)/stories.length, 0.4, 0.7, 1.);
                                let shadowcolor = sampleOKHSL((selectedStoryIndex-1)/stories.length, 0.5, 0.75, 0.15);
                                charSpan.style.textShadow = `0 0 10px ${shadowcolor}, 0 0 10px ${shadowcolor}, 0 0 10px ${shadowcolor}, 0 0 10px ${shadowcolor}`;
                                if(isDarkMode){
                                    charSpan.style.color = sampleOKHSL((selectedStoryIndex-1)/stories.length, 0.4, 0.7, 1.);
                                    let shadowcolor = sampleOKHSL((selectedStoryIndex-1)/stories.length, 0.5, 0.75, 0.15);
                                    charSpan.style.textShadow = `0 0 10px ${shadowcolor}, 0 0 10px ${shadowcolor}, 0 0 10px ${shadowcolor}, 0 0 10px ${shadowcolor}`;
                                }
                            }

                            charContainer.appendChild(pinyinElement);
                            charContainer.appendChild(charSpan);
                            currentWrapper.appendChild(charContainer);

                            if (char in dataPerCharacter) {
                                if (dataPerCharacter[char].pinyin) {
                                    pinyinElement.textContent = dataPerCharacter[char].pinyin;
                                }
                            } 
                        } else {
                            let canvasContainer = document.createElement('div');
                            let pinyinElement = document.createElement('div');

                            plotter.draw();
                            plotter.canvas.dataset.plotterIndex = index;
                            
                            canvasContainer.style.position = 'relative';
                            canvasContainer.style.display = 'inline-block';
                            canvasContainer.classList.add('plotterContainer');
                            
                            pinyinElement.style.textAlign = 'center';
                            pinyinElement.style.userSelect = 'none';
                            pinyinElement.style.height = '20px';
                            if (!showAllPinyin) {
                                pinyinElement.classList.add('hidden');
                            }
                            pinyinElement.classList.add('pinyinLabel');
                            pinyinElement.classList.add('pinyinLabelColor');
                            pinyinElement.classList.add('line_' + lineIndex);
                            canvasContainer.addEventListener('click', function() {
                                let prompt = 'explain to me briefly the function of the word/character ' + char + ' in the context of the sentence: "' + currentLines[lineIndex] + '". If it belongs to a word alongside other characters, please explain the word as a whole. Be brief, don\'t repeat the sentence. If the char is not in the sentence, dont mention that fact, pretend its there.';

                                if(lineIndex !== currentHoveredLine){
                                    return;
                                }
                                makeAIBubble(prompt);
                                translationBox.classList.add('hidden');

                            });
                            

                            canvasContainer.appendChild(pinyinElement);
                            canvasContainer.appendChild(plotter.getCanvas());

                            canvasContainer.classList.add('line_' + lineIndex);

                            currentWrapper.appendChild(canvasContainer);

                            if (char in dataPerCharacter) {
                                let strokes = dataPerCharacter[char].strokes.medians.map(stroke => {
                                    stroke.map(point => {
                                        point.x = point[0];
                                        point.y = point[1];
                                    });
                                    let spoints = evenOutPoints(stroke, 22);
                                    return spoints;
                                });
                                let pinyinAndEnglish = { pinyin: dataPerCharacter[char].pinyin, english: null };
                                if (pinyinAndEnglish && pinyinAndEnglish.pinyin) {
                                    pinyinElement.textContent = pinyinAndEnglish.pinyin;
                                }
                            } else {
                                let readyPromise = loadStrokeData();
                                plotter.loadPinyinEnglish();
                            }
                        }
                    } else {
                        let latin = document.createElement('span');
                        latin.classList.add('latin');
                        latin.innerHTML = plotterinfo.char;
                        
                        latin.style.color = colors[0];
                        let rs = 50;
                        if(useTextRendering)
                            rs = 50;
                        if (isMobileOrTablet()) {
                            latin.style.fontSize = size/rs + 'em';
                        } else {
                            latin.style.fontSize = size/rs + 'em';
                        }
                        latin.style.userSelect = 'none';
                        currentWrapper.appendChild(latin);
                    }
                });
            }


            function redrawPlotters() {
                let titleHanzi = story.name + "\n";
                //prepend title to story.hanzi
                let joinedLines = story.hanzi.join('\n');
                let currentLines = story.hanzi;
                let numLines = currentLines.length;
                let lineIndex = -1;
                let titlelength = titleHanzi.length;
                let characters = titleHanzi.split('').concat(joinedLines.split(''));

                const plotterElement = document.getElementById('plotters');
                plotterElement.innerHTML = '';
                plotters = [];
                
                let size = parseFloat(sizeSlider.value)*2;

                let storyTitleElem = document.createElement('div');
                storyTitleElem.classList.add('story-title');
                storyTitleElem.style.fontFamily = renderFont;
                storyTitleElem.style.fontSize = size / 40 + 'em';
                storyTitleElem.textContent = titleHanzi;

                let speed = parseFloat(speedSlider.value/70);
                let lineThickness = parseFloat(thicknessSlider.value*size/200);
                let jitterAmp = parseFloat(noiseSlider.value*30);
                colors = ['#111'];
                if(isDarkMode){
                    colors = ['#ddd'];
                }
                
                let lineType = 'round'; 
                lineType = 'round'; 
                lineType = 'miter'; 
                if (isMobileOrTablet()) {
                    // console.log('Mobile or tablet detected');
                    // size = 48;
                }
                characters.forEach((char, index) => {
                    let strokes = undefined;
                    if(dataPerCharacter){
                        if(dataPerCharacter[char]){
                            strokes = dataPerCharacter[char].strokes.medians;
                        }
                    }
                    if (isHanzi(char) && !isPunctuation(char)) {
                        let usedcolors = [...colors];
                        if(lineIndex === -1){
                            let tt = sampleOKHSL((selectedStoryIndex-1)/stories.length, 0.4, 0.7, 1.);
                            if(isDarkMode){
                                let tt = sampleOKHSL((selectedStoryIndex-1)/stories.length, 0.4, 0.7, 1.);
                            }
                            
                            usedcolors = [tt,tt,tt]
                        }
                        const plotter = new HanziPlotter({
                            character: char,
                            strokes: strokes,
                            dimension: size * (1 + .2*(lineIndex===-1)),
                            speed: speed,
                            lineThickness: lineThickness,
                            jitterAmp: jitterAmp,
                            colors: usedcolors,
                            lineType: lineType,
                            showDiagonals: backgroundCheckbox.checked,
                            showGrid: backgroundCheckbox2.checked,
                        });
                        plotters.push({ plotter: plotter, char: char, lineIndex: lineIndex });
                    }
                    else {
                        plotters.push({ plotter: null, char: char, lineIndex: lineIndex });
                        if (char === '\n') {
                            plotters.push({ plotter: null, char: '<br>', lineIndex: lineIndex });
                            lineIndex++;
                        }
                    }
                });
                if (plotters.length > 0) {
                    plottersElem.classList.remove('empty');
                }
                else {
                    plottersElem.classList.add('empty');
                }

                if (plotterElement && plotters) {
                    renderPlottersToDOM(plotterElement, plotters, showAllPinyin, colors, size, dataPerCharacter, currentLines, storyTitleElem);
                }

            }

            function throttle(func, limit) {
                let inThrottle = false;
                return function (...args) {
                    if (!inThrottle) {
                        func.apply(this, args);
                        inThrottle = true;
                        setTimeout(() => {
                            inThrottle = false;
                        }, limit);
                    }
                }
            }

            function updateCount() {
                let hanziCount = document.getElementById('hanziCount');
                hanziCount.textContent = input.value.length + ' characters';
            }
            
        </script>

        <div class="dropdown-menu" id="dropdownMenu">
            <ul>
                <li id="loginMenuItem"><a href="{{ url_for('login') }}">Login</a></li>
                <li><a href="{{ url_for('home') }}">Home</a></li>
                <li class="has-submenu">
                    <span>Hanzi Grid</span>
                    <ul class="submenu">
                        {% for key, deck in decks.items() %}
                            <li><a href="{{ url_for('grid') }}?deck={{ key }}">{{ deck.name }}</a></li>
                            {% endfor %}
                    </ul>
                </li>
                <li class="has-submenu">
                    <span>Flashcards</span>
                    <ul class="submenu">
                        {% for key, deck in decks.items() %}
                            <li><a href="{{ url_for('flashcards') }}?deck={{ key }}">{{ deck.name }}</a></li>
                            {% endfor %}
                    </ul>
                </li>
                <!-- <li class="has-submenu">
                    <span>Fonts</span>
                    <ul class="submenu">
                        <li><a href="#" class="font-change" data-font="Noto Sans Mono">Noto Sans Mono</a></li>
                        <li><a href="#" class="font-change" data-font="Noto Serif SC">Noto Serif SC</a></li>
                        <li><a href="#" class="font-change" data-font="Kaiti">Kaiti</a></li>
                    </ul>
                </li> -->
                <li class="has-submenu">
                    <span>Stuff</span>
                    <ul class="submenu">
                        <li><a href="{{ url_for('search') }}">Search</a></li>
                        <li><a href="{{ url_for('convert') }}">Convert to strokes</a></li>
                        <li><a href="{{ url_for('stories') }}">Stories</a></li>
                        <!-- <li><a href="{{ url_for('lists') }}">Example Lists</a></li> -->
                        <li><a href="{{ url_for('puzzles.puzzles') }}">Puzzles</a></li>
                        <li><a href="{{ url_for('hanzipractice') }}">Practice 汉字</a></li>
                        <li><a href="{{ url_for('pageinfo') }}">Info</a></li>
                    </ul>
                </li>
                <li><span id="darkmode-toggle" >Toggle darkmode</span></li>
                <li><a href="{{ url_for('logout') }}" id="logoutButton">Logout</a></li>
            </ul>
        </div>
        
        <script>

            function isMobileOrTablet() {
                let check = false;
                (function (a) { if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4))) check = true; })(navigator.userAgent || navigator.vendor || window.opera);
                return check || /iPad|iPhone|iPod/.test(navigator.platform) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
            }
        </script>
        <script src="{{ url_for('static', filename='js/hamburger.js') }}"></script>
        <!-- <script src="{{ url_for('static', filename='js/contextmenu.js') }}"></script> -->
        <script src="{{ url_for('static', filename='js/darkmode.js') }}"></script>
    </body>

</html>